<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fabian Londen</title>

  <style>
    html, body { margin: 0; height: 100%; background: #111; overflow: hidden; }

    #bar {
      position: fixed;
      top: 10px; left: 10px; right: 10px;
      display: flex; gap: 8px; align-items: center;
      z-index: 10;
      pointer-events: none;
    }
    .btn, #status {
      pointer-events: auto;
      font: 14px/1 system-ui, -apple-system, Arial, sans-serif;
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(20,20,20,.7);
      color: #fff;
      border-radius: 10px;
      padding: 10px 12px;
      user-select: none;
      white-space: nowrap;
    }
    .btn { cursor: pointer; }
    .btn:active { transform: translateY(1px); }

    #viewport {
      position: absolute; inset: 0;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      cursor: grab;
      background: #111;
    }
    #viewport.dragging { cursor: grabbing; }

    #stage {
      min-width: 100%;
      min-height: 100%;
      display: grid;
      place-items: center;
      padding: 40px;
      box-sizing: border-box;
    }

    canvas { display: block; }
  </style>
</head>
<body>

  <div id="bar">
    <div class="btn" id="zoomOut">−</div>
    <div class="btn" id="zoomIn">+</div>
    <div class="btn" id="fit">Fit</div>
    <div class="btn" id="prev">←</div>
    <div class="btn" id="next">→</div>
    <div id="status">Sida <span id="pageNum">1</span>/<span id="pageCount">?</span> • <span id="zoomPct">100</span>%</div>
  </div>

  <div id="viewport">
    <div id="stage">
      <canvas id="pdf"></canvas>
    </div>
  </div>

  <script type="module">
    import * as pdfjsLib from "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.min.mjs";
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.mjs";

    const url = "./exempel.pdf";

    const canvas = document.getElementById("pdf");
    const ctx = canvas.getContext("2d", { alpha: false });

    const viewportEl = document.getElementById("viewport");
    const pageNumEl = document.getElementById("pageNum");
    const pageCountEl = document.getElementById("pageCount");
    const zoomPctEl = document.getElementById("zoomPct");

    const zoomInBtn = document.getElementById("zoomIn");
    const zoomOutBtn = document.getElementById("zoomOut");
    const fitBtn = document.getElementById("fit");
    const prevBtn = document.getElementById("prev");
    const nextBtn = document.getElementById("next");

    let pdfDoc = null;
    let pageNumber = 1;
    let scale = 1;
    let baseFitScale = 1;

    // Render control
    let renderToken = 0;
    let renderInFlight = null;
    let rafId = null;

    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

    async function computeFitScale() {
      const page = await pdfDoc.getPage(pageNumber);
      const vp1 = page.getViewport({ scale: 1 });
      const padding = 80;
      const fitW = (viewportEl.clientWidth - padding) / vp1.width;
      baseFitScale = clamp(fitW, 0.2, 4);
      return baseFitScale;
    }

    // ---- Zoom-to-cursor anchor ----
    // Sparar senast kända musposition (i scroll-koordinater) inom viewport.
    // När vi zoomar använder vi denna punkt som "ankare".
    let lastMouse = null; // { xScroll, yScroll }
    viewportEl.addEventListener("mousemove", (e) => {
      const r = viewportEl.getBoundingClientRect();
      const xInViewport = e.clientX - r.left;
      const yInViewport = e.clientY - r.top;
      lastMouse = {
        xScroll: viewportEl.scrollLeft + xInViewport,
        yScroll: viewportEl.scrollTop + yInViewport,
      };
    });

    function getAnchorRatios(useMouse) {
      const oldW = viewportEl.scrollWidth || 1;
      const oldH = viewportEl.scrollHeight || 1;

      if (useMouse && lastMouse) {
        return { ax: lastMouse.xScroll / oldW, ay: lastMouse.yScroll / oldH, useMouse: true };
      }

      // fallback: center
      const cx = viewportEl.scrollLeft + viewportEl.clientWidth / 2;
      const cy = viewportEl.scrollTop + viewportEl.clientHeight / 2;
      return { ax: cx / oldW, ay: cy / oldH, useMouse: false };
    }

    function restoreAnchor(ax, ay, useMouse) {
      const newW = viewportEl.scrollWidth || 1;
      const newH = viewportEl.scrollHeight || 1;

      // var ska ankaret ligga i viewporten efter zoom?
      // Om vi zoomar med musen: håll ankaret på samma skärmpunkt (mouse pos).
      // Annars: håll det i mitten.
      let targetXInViewport = viewportEl.clientWidth / 2;
      let targetYInViewport = viewportEl.clientHeight / 2;

      if (useMouse && lastMouse) {
        // mouse position i viewport (före zoom) ~ används som target
        const r = viewportEl.getBoundingClientRect();
        // lastMouse xScroll = scrollLeft + xInViewport => xInViewport = lastMouse - scrollLeft
        targetXInViewport = clamp(lastMouse.xScroll - viewportEl.scrollLeft, 0, viewportEl.clientWidth);
        targetYInViewport = clamp(lastMouse.yScroll - viewportEl.scrollTop, 0, viewportEl.clientHeight);
      }

      const targetScrollLeft = ax * newW - targetXInViewport;
      const targetScrollTop  = ay * newH - targetYInViewport;

      viewportEl.scrollLeft = clamp(targetScrollLeft, 0, newW);
      viewportEl.scrollTop  = clamp(targetScrollTop, 0, newH);
    }

    async function doRender(keepAnchor, anchorFromMouse) {
      const myToken = ++renderToken;

      if (renderInFlight && renderInFlight.cancel) {
        try { renderInFlight.cancel(); } catch {}
      }

      const { ax, ay, useMouse } = keepAnchor ? getAnchorRatios(anchorFromMouse) : { ax: 0.5, ay: 0, useMouse: false };

      const page = await pdfDoc.getPage(pageNumber);
      const dpr = window.devicePixelRatio || 1;
      const vp = page.getViewport({ scale });

      canvas.width = Math.floor(vp.width * dpr);
      canvas.height = Math.floor(vp.height * dpr);
      canvas.style.width = Math.floor(vp.width) + "px";
      canvas.style.height = Math.floor(vp.height) + "px";

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.fillStyle = "#111";
      ctx.fillRect(0, 0, vp.width, vp.height);

      renderInFlight = page.render({ canvasContext: ctx, viewport: vp });

      try {
        await renderInFlight.promise;
      } catch (e) {
        if (e?.name !== "RenderingCancelledException") console.error(e);
        return;
      }

      if (myToken !== renderToken) return;

      pageNumEl.textContent = String(pageNumber);
      pageCountEl.textContent = String(pdfDoc.numPages);
      zoomPctEl.textContent = String(Math.round(scale * 100));

      if (keepAnchor) restoreAnchor(ax, ay, useMouse);
    }

    function queueRender(keepAnchor = true, anchorFromMouse = false) {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        rafId = null;
        doRender(keepAnchor, anchorFromMouse);
      });
    }

    async function fitToWidth() {
      scale = await computeFitScale();
      queueRender(false);
      viewportEl.scrollLeft = 0;
      viewportEl.scrollTop = 0;
    }

    // ==== Pan (hand) ====
    let isDown = false, startX = 0, startY = 0, startLeft = 0, startTop = 0;

    viewportEl.addEventListener("mousedown", (e) => {
      if (e.target.closest("#bar")) return;
      isDown = true;
      viewportEl.classList.add("dragging");
      startX = e.clientX;
      startY = e.clientY;
      startLeft = viewportEl.scrollLeft;
      startTop = viewportEl.scrollTop;
    });

    window.addEventListener("mousemove", (e) => {
      if (!isDown) return;
      viewportEl.scrollLeft = startLeft - (e.clientX - startX);
      viewportEl.scrollTop = startTop - (e.clientY - startY);
    });

    window.addEventListener("mouseup", () => {
      isDown = false;
      viewportEl.classList.remove("dragging");
    });

    // ==== Zoom: Ctrl/⌘ + scroll (zooma mot muspekaren) ====
    viewportEl.addEventListener("wheel", (e) => {
      if (!(e.ctrlKey || e.metaKey)) return;
      e.preventDefault();

      const factor = e.deltaY < 0 ? 1.12 : 0.89;
      scale = clamp(scale * factor, 0.2, 6);

      // keepAnchor=true, anchorFromMouse=true
      queueRender(true, true);
    }, { passive: false });

    // ==== Buttons (zooma mot mitten) ====
    zoomInBtn.onclick = () => { scale = clamp(scale * 1.15, 0.2, 6); queueRender(true, false); };
    zoomOutBtn.onclick = () => { scale = clamp(scale / 1.15, 0.2, 6); queueRender(true, false); };
    fitBtn.onclick = () => { fitToWidth(); };

    prevBtn.onclick = async () => {
      if (!pdfDoc) return;
      pageNumber = Math.max(1, pageNumber - 1);
      await fitToWidth();
    };

    nextBtn.onclick = async () => {
      if (!pdfDoc) return;
      pageNumber = Math.min(pdfDoc.numPages, pageNumber + 1);
      await fitToWidth();
    };

    window.addEventListener("resize", async () => {
      if (!pdfDoc) return;
      const rel = scale / (baseFitScale || 1);
      await computeFitScale();
      scale = clamp(rel * baseFitScale, 0.2, 6);
      queueRender(false);
    });

    // ==== Load ====
    try {
      pdfDoc = await pdfjsLib.getDocument(url).promise;
      pageCountEl.textContent = String(pdfDoc.numPages);
      await fitToWidth();
    } catch (e) {
      document.body.innerHTML =
        "<p style='color:#fff;font-family:system-ui;padding:20px'>Kunde inte ladda PDF. Kontrollera att filen heter <b>exempel.pdf</b> och ligger i samma mapp som <b>index.html</b>.</p>";
      console.error(e);
    }
  </script>
</body>
</html>

